
Проект:
    Реализация игры "Морской Бой" на python. Автор: Хатымов Ренат, Б05-224.
По поводу багов и ошибок писать на: t.me/renatxat

Установка:
0) Установите python 3.8+
1) Откройте папку morskoy_boy как проект.
2) Пропишите в терминале pip freeze > requirements.txt. Если у вас linux, то скачайте ещё модуль tkinter
при помощи следующих команд:
sudo apt update
sudo apt install python3-tk
3) Запустите файл main.py и наслаждайтесь игрой.


    Основная логика:

        При запуске main.py создаётся объект класса ConstructorFields, открываются окна для
    расстановки ваших кораблей. Когда все корабли будут верно расставлены, запускается класс 
    Application из application_game.py, в котором генерируется ваше поле из вами расставленных
    кораблей и поле бота(вашего соперника), всё это отрисовывается для дальнейшего взаимодействия с юзером.
    Подробнее:
    1) В Application создаётся объект __field класса BattlefieldPlayer из battlefield_player_view.py.
    Это доска справа, на которой отображается то, как ходит бот, обновление происходит методом update.
    2) В Application создаётся объект __foreign_field класса BattlefieldBotOpponent из battlefield_bot_view.py.
    Это доска слева, корабли на которой бот генерирует сам, вы можете нажимать на кнопки на ней,
    когда есть надпись "Ходите". Так вы и ходите.
    3) В Application создаётся объект __bot_field класса BattlefieldBotPlayer из battlefield_bot.py.
    Это невидимая доска, на которой делает ходы бот, отображается это в (см пункт (1)).
    Бот сам рандомно генерирует ходы.
    4) Все доски имеют методы presence_of_changes, get_last_shot, exist_hit_last_shot, благодаря чему можно
    отслеживать их состояние и понимать, кто должен ходить. Вся логика этого взаимодействия прописана в бесконченом
    цикле __loop в Application.

    Классы:

    1) Класс Ship создаёт корабли по переданным координатам, в которые можно стрелять посредством метода shot.
    Этот метод возвращает set с координатами клеток, окружающих корабль, если он убит, и пустой set,
    если просто ранен.
    Так же можно отдельно попросить вывести окружающие корабль клетки методом get_environment. Это сильно
    используется при реализации классов ConstructorFields, BattlefieldBotOpponent.

    2) Класс Battlefield выполняют всю логику основного игрового поля. В него можно стрелять при помощи метода
    shot_. Его основное поле это двумерный список _field. Изначально оно содержит нули для пустых клеток и
    соответствующие корабли для непустых. При выстрелах значения в некоторых клетках заменяются на "miss" и "hit".
      Он хранит в себе состояниe наличия кораблей (__game_run), которое обнуляется,
    если все корабли будут убиты (количество живых хранит в __quantity_ships).
      Также он хранит в себе состояние наличия необработанного выстрела _existence_of_raw_shot. Выстрел
    обрабатывается посредством двойного вызова метода exist_hit_last_shot, если последний выстрел был "miss",
    и одинарным, если "hit", или как-то иначе в наследуемых классах без кнопок (только BattlefieldPlayer).
      Ещё он хранит в себе координаты клетки этого последнего выстрела для передачи её другим объектам,
    в поле __last_shot, чтобы и в них делать выстрелы. Можно посмотреть при помощи метода get_last_shot.
    Это необходимо для обновления объектов класса BattlefieldPlayer.

    3) Класс BattlefieldPlayer является наследником класса Battlefield. Он просто является фасадом для него.
    Отображает все изменения в правой части доски, вызванные методом update.

    4) Класс BattlefieldOpponent создаёт поле слева для игрока с полем противника (бота в нашем случае),
    состоящее из кнопок, на которые игрок кликает в ходе игры. Является интерфейсом. Обновляется всё автоматически,
    так как при нажатии вызывается метод __update.

    5) Класс BattlefieldBotPlayer является наследником класса Battlefield. Он самостоятельно генерирует выстрелы
    методом take_a_shot при помощи библиотеки random и стреляет по себе.

    6) Класс BattlefieldBotOpponent является наследником класса BattlefieldOpponent. Отличается от него только 
    собственной генерацией кораблей на поле. Сделано это при помощи библиотеки random и леммой,
    выведенной автором самостоятельно. Она же используются по сути при вводе расположения кораблей игроком в
    классе ConstructorFields. Далее её формулировка, с доказательством можете ознакомиться в самом
    конце данного файла. 
      Если расставлять корабли из морского боя на поле 10х10 в порядке неувеличения их размеров
    произвольным образом в соотвествии с правила морского боя, то этот процесс всегда удасться довести до конца.

    7) Класс Application. Он создаёт окно из модуля tkinter, создаёт в нём canvas и рисует на нём два поля.
    Поле бота слева __foreign_field, на которое ходит игрок, и поле __field справа, на которое ходит сам бот.
    См. Логику.

    8) Создаётся окно с двумя кнопками выбора режима игры: играть с ботом, играть онлайн.
    Второй режим пока не реализован. Выбираем первый режим. Далее рисуется игровое поле и надпись сверху с просьбой
    разместить корабль того или иного размера. При неправильном выборе клеток корабля выскакивает окно с перезапуском
    размещения только этого корабля. Для полного перезапуска закройте игровое окно и запустие main.py заново. Когда
    все корабли будут расставлены верно (10 штук) автоматически закроется действующее игровое окно и запустится
    класс Application, в котором и будет происходить сама игра с ботом.
    


Доказательство Леммы: 
    1) На пустом поле 10х10 произвольным образом разместить прямоугольник 1х4 очевидно можно. 
    2) Разместим на поле 8 зелёных прямоугольников 1х3, как показано на рисунке. Заметим, что любой прямоугольничек 
1х3 или 1х4 портит не более 2 из этих зелёных прямоугольников (портит = делает невозможным на нём размещение
корабля 1х3 по правилам морского боя). Тогда предположим, что мы выставляли прямоугольнички от большего к меньшему,
новый поставить не смогли, и это был 1х3. Тогда мы заняли ≤2∙2 зелёных прямоугольников, значит, есть свободный,
туда очевидно можно положить прямоугольничек 1х3.\
![img_2.png](img_2.png)\
    3) Аналогично выделим 12 синих прямоугольников 1х2. Если мы не можем выставить прямоугольничек 1х2, то
мы заняли ≤2∙5 синих прямоугольников, значит, есть свободный, туда очевидно можно положить прямоугольничек 1х2.\
![img_1.png](img_1.png)\
    4) Аналогично выделим 16 фиолетовых квадратов 1х1. Каждый корабль портит не более двух фиолетовых квадратиков,
а квадратик 1х1 так вообще всегда только 1. Если мы не можем выставить квадратик 1х1, то мы заняли ≤2∙6+1∙3 
фиолетовых квадратов, значит, есть свободный, туда очевидно можно положить квадратик 1х1.\
![img_3.png](img_3.png)\
    ЧТД.








    
